## 8. 기능과 책임 분리

### 기능 분해

- 기능은 하위 기능으로 분해

<br>

### 기능을 누가 제공할 것인가?

- 기능은 곧 책임
- 분리한 각 기능을 알맞게 분해

<br>

### 큰 클래스, 큰 메서드

- 클래스나 메서드가 커지면 절차 지향의 문제가 발생
  - 큰 클래스 -> 많은 필드를 많은 메서드가 공유
  - 큰 메서드 -> 많은 변수를 많은 코드가 공유
  - 여러 기능이 한 클래스/메서드에 섞여 있을 가능성
- 책임에 따라 알맞게 코드 분리가 필요

<br>

### 책임 분배/분리 방법

1. 패턴 적용
2. 계산 기능 분리
3. 외부 연동 분리
4. 조건별 분기는 추상화

<br>

### 패턴 적용

- 전형적인 역할 분리
  - 간단한 웹
    - 컨트롤러, 서비스, DAO
  - 복잡한 도메인
    - 엔티티, 밸류, 리포지포리, 도메인 서비스
  - AOP
    - Aspect(공통 기능)
  - GoF
    - 팩토리, 빌더, 전략, 템플릿 메서드, 프록시/데코레이터 등

<br>

### 계산 분리

- 계산을 처리하는 부분을 담당하는 역활 클래스 생성

<br>

### 연동 분리

- 네트워크, 메시징, 파일 등 연동 처리 코드를 분리

<br>

### 조건 분기는 추상화

- 연속적인 if-else는 추상화 고민

<br>

### 주의 : 의도가 잘 드러나는 이름 사용

- 예, HTTP로 추천 데이터 읽어오는 기능 분리시
  - RecommendService > HttpDataService

<br>

### 역할 분리와 테스트

- 역할 분리가 잘 되면 테스트도 용이

<br>

=> 하위 기능을 분리하고 하위 기능을 알맞은 객체에게 배분하는 것